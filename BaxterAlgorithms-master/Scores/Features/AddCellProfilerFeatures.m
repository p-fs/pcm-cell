function AddCellProfilerFeatures(aBlobs, aFilename, aT)
% Loads features computed in CellProfiler and stores them in blobs.
%
% The function reads features from a feature file generated by CellProfiler
% and stores the features in the feature field of blobs which have been
% segmented using CellProfiler. The segmentation algorithm has to be set to
% Segment_import, to make sure that the blob indices match the object
% indices in the feature files. One feature file from CellProfiler contains
% features for all blobs in an image sequence, so to avoid reading the
% feature file multiple times, the function stores the information from the
% feature file in persistent variables. Information from old files are
% cleared when 3 new files have been loaded, to avoid running out of
% memory.
%
% Inputs:
% aBlobs - Array of Blob objects for which features should be loaded.
% aFilename - The full file of the feature file. Normally, the file should
%             be named 'labels.csv' and be placed in the same folder as the
%             tif-images with segmentation labels generated in
%             CellProfiler.
% aT - The index of the image that the blobs come from.
%
% See also:
% Segment_import, ComputeFeatures


persistent filenames        % Full paths of previously read feature files.
persistent featureMatrices  % Matrices with features from the files.
persistent featureNames     % Cell arrays of strings with feature names.
persistent imageNumbers     % Indices specifying what images the rows in
% the feature matrices correspond to.
persistent objectNumbers    % Indices specifying what blobs the rows in
% the feature matrices correspond to.

% The number of feature files from which data will be kept in memory.
CASH_SIZE = 3;

if ~any(strcmpi(filenames, aFilename))
    % Read data from a new file.
    
    if ~exist(aFilename, 'file')
        return
    end
    
    spreadSheet = ReadDelimMat(aFilename, ',');
    
    headings = spreadSheet(1,:);
    
    % Find indices for images and blobs.
    imageNumber = cellfun(@str2double,...
        spreadSheet(2:end, strcmp(headings,'ImageNumber')));
    objectNumber = cellfun(@str2double,...
        spreadSheet(2:end, strcmp(headings,'ObjectNumber')));
    
    % Remove columns that are not features.
    featureSheet = spreadSheet;
    notFeatures = {...
        'ImageNumber'
        'ObjectNumber'
        'Location_Center_X'
        'Location_Center_Y'
        'Number_Object_Number'};
    deleteIndices = false(1,size(featureSheet,2));
    for i = 1:length(notFeatures)
        index = find(strcmp(headings, notFeatures{i}));
        if ~isempty(index)
            deleteIndices(index) = true;
        end
    end
    featureSheet(:,deleteIndices) = [];
    
    % Get feature names and features.
    featureName = featureSheet(1,:);
    featureMatrix = cellfun(@str2double, featureSheet(2:end,:));
    
    % Store data from the read file in persistent variables.
    filenames = [{aFilename}; filenames];
    featureMatrices = [{featureMatrix}; featureMatrices];
    featureNames = [{featureName}; featureNames];
    imageNumbers = [{imageNumber}; imageNumbers];
    objectNumbers = [{objectNumber}; objectNumbers];
    
    % Remove cashed data so that we don't run out of memory.
    if length(filenames) > CASH_SIZE
        filenames = filenames(1:CASH_SIZE);
        featureMatrices = featureMatrices(1:CASH_SIZE);
        featureNames = featureNames(1:CASH_SIZE);
        imageNumbers = imageNumbers(1:CASH_SIZE);
        objectNumbers = objectNumbers(1:CASH_SIZE);
    end
else
    % Use data from a previously read file.
    fileIndex = find(strcmpi(filenames, aFilename));
    featureMatrix = featureMatrices{fileIndex};
    featureName = featureNames{fileIndex};
    imageNumber = imageNumbers{fileIndex};
    objectNumber = objectNumbers{fileIndex};
end

% Set feature values for the blobs.
inImageT = find(imageNumber == aT);
for i = 1:length(inImageT)
    index = inImageT(i);
    for j = 1:length(featureName)
        aBlobs(objectNumber(index)).features.(featureName{j}) =...
            featureMatrix(index,j);
    end
end
end