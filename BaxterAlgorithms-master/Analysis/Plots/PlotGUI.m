function PlotGUI(aSeqPaths)
% GUI where tracking results can be analyzed using plotting functions.
%
% The user gets to select a number of image sequences, a tracking version,
% and one or more plotting functions. The user then executes the plotting
% functions by pressing the Plot button. Descriptions of the selected
% plotting functions are displayed in a text box. The same texts can be
% viewed by pressing the Caption menu in the plotting figures, and they
% will also be used as captions if the figures are exported to a tex- or
% pdf-document. Different plotting styles can be selected in a popup-menu.
% The plots can be exported to different file formats by pressing the Save
% plots button. New plotting functions can be added to the GUI by creating
% new elements in the struct array funcs. The plotting functions need to
% take an array of Cell objects and a figure as inputs.
%
% Inputs:
% aSeqPaths - Cell array with full paths of image sequences. The folder
%             names at the ends of the paths will be displayed in the list
%             of image sequences.
%
% See also:
% CellAnalysisPlayer, PopulationAnalysisGUI, SavePlotsGUI, TrackingGUI

mainFigure = figure('Name', 'Plot GUI',...
    'NumberTitle', 'off',...
    'MenuBar', 'none',...
    'ToolBar', 'none',...
    'Units', 'normalized',...
    'Position', [0.1 0.1 0.25 0.75]);

[exPaths, seqDirs] = FileParts2(aSeqPaths);

% Create a list of all tracking versions. The versions do not have to exist
% for all image sequences.
vers = GetVersions(aSeqPaths);
vers = unique([vers{:}]);
if isempty(vers)
    warndlg(['None of the image sequences have been tracked. You need '...
        'to run the tracking before you can analyze the results.'],...
        'No tracking results')
    % This will be displayed in the popup-menu. The user will not be able
    % to do anything in the GUI, but it is nice to be able to look at it
    % without having tracked anything.
    vers = {'NO TRACKING RESULTS AVAILABLE!'};
    noTracking = true;
else
    noTracking = false;
end

% This struct array has information about all plotting functions that can
% be called. The field 'function' has  a function handle for the plotting
% function, that takes an array of cell objects and a figure as inputs. The
% field 'name' will be displayed in the list of functions and at the top of
% the figure with the plot. Because 'name' is used as the figure name, it
% will also be used as the file name if the figure is exported. The field
% 'caption' is a string that explains the plot. That string will be
% displayed in a text box in the GUI when the plotting function is
% selected. The string can also be displayed if the user clicks the
% Caption menu in the figure with the plot. If the figure is exported to a
% tex- or pdf-document, the string will be inserted as a figure caption.
funcs = [
    struct('function', @CellAge,...
    'name', 'Cell age',...
    'caption', ['The average cell age as a function of time. Cells '...
    'present in the first image are said to start with an age of 0, and '...
    'therefore the cell age will be under-estimated in the beginning '...
    'of the experiment.'])
    
    struct('function', @AgeHistogram,...
    'name', 'Cell age histogram',...
    'caption', ['Histogram over the ages of the cells in the last '...
    'images of the sequences.'])
    
    struct('function', @AxisRatioOverTime,...
    'name', 'Cell axis ratio over time',...
    'caption', ['Cell axis ratio over time. The axis ratio is averaged '...
    'over the cells in each time point.'])
    
    struct('function', @(x,y)FateProbabilityGeneration(x, y,...
    'Normalization', 'start'),...
    'name', 'Cell fate per generation',...
    'caption', ['The number of cells that where alive, had divided or '...
    'had died at the end of the experiment, plotted per generation. '...
    'The cell counts are normalized to starting populations of 100 cells.'])
    
    struct('function', @(x,y)FateProbabilityGeneration(x, y,...
    'Normalization', 'percentage'),...
    'name', 'Cell fate per generation (fractions)',...
    'caption', ['The fractions of the cells that where alive, had '...
    'divided, or had died at the end of the experiment, plotted per '...
    'generation.'])
    
    struct('function', @(x,y)FateProbabilityGeneration(x, y,...
    'LiveOrDead', true, 'Normalization', 'start'),...
    'name', 'Cell fate per generation (live and dead)',...
    'caption', ['The number of live and dead cells at the end of the '...
    'experiment, plotted per generation. The cell counts are '...
    'normalized to starting populations of 100 cells.'])
    
    struct('function', @SizeOverTime,...
    'name', 'Cell size over time',...
    'caption', ['Cell size over time. The size is averaged over the '...
    'cells in each time point.'])
    
    struct('function', @SpeedOverTime,...
    'name', 'Cell speed over time',...
    'caption', ['Cell speed over time. The speed is averaged over the '...
    'cells in each time point.'])
    
    struct('function', @CloneSize,...
    'name', 'Clone size over time',...
    'caption', ['Clone sizes over time. The clones are on the y-axis '...
    'and clone sizes are shown in different colors.'])
    
    struct('function', @(x,y)CloneViability(x, y, 'PlotDeath', false),...
    'name', 'Clone viability over time',...
    'caption', ['Clone viability over time. The viability is defined '...
    'as the fraction of a lineage tree that is not dead.'])
    
    struct('function', @CloneViability,...
    'name', 'Clone viability over time (death markers)',...
    'caption', ['Clone viability over time. The viability is defined '...
    'as the fraction of a lineage tree that is not dead. Death events '...
    'are indicated by circles.'])
    
    struct('function', @DeadCellRatio,...
    'name', 'Dead cell percentage over time',...
    'caption', 'The percentage of the total number of cells that are dead.')
    
    struct('function', @DeadCount,...
    'name', 'Dead cells',...
    'caption', ['The number of dead cells as a function of time. The '...
    'cell count is normalized to percent of the starting population.'])
    
    struct('function', @DivisionCount,...
    'name', 'Division count',...
    'caption', ['The number of cell divisions that have taken place in '...
    'the experiment, as a function of time. The number is normalized '...
    'to percent of the starting population.'])
    
    struct('function', @(x,y)GenerationDistribution(x, y,...
    'Normalization', 'start'),...
    'name', 'Generation distribution over time',...
    'caption', ['The number of cells in different generations as a '...
    'function of time. The cell counts are normalized to a starting '...
    'population of 100 cells.'])
    
    struct('function', @(x,y)GenerationDistribution(x, y,...
    'Type', 'dead', 'Normalization', 'start'),...
    'name', 'Generation distribution over time (dead)',...
    'caption', ['The number of dead cells from different generations '...
    'as a function of time. The cell counts are normalized to a '...
    'starting population of 100 live cells.'])
    
    struct('function', @(x,y)GenerationDistribution(x, y,...
    'Type', 'liveanddead', 'Normalization', 'start'),...
    'name', 'Generation distribution over time (live and dead)',...
    'caption', ['The number of live and dead cells in different '...
    'generations as a function of time. The cell counts are normalized '...
    'to a starting population of 100 live cells.'])
    
    struct('function', @(x,y)GenerationDistribution(x, y,...
    'Normalization', 'percentage'),...
    'name', 'Generation distribution over time (percentage)',...
    'caption', ['The proportions of the cells that belong to different '...
    'generations, as a function of time.'])
    
    struct('function', @(x,y)LiveDeadGhost(x, y, 'GhostCells', false),...
    'name', 'Live and dead cells',...
    'caption', 'The number of live and dead cells as a function of time.')
    
    struct('function', @(x,y)LiveDead(x, y),...
    'name', 'Live and dead cells at the end',...
    'caption', ['The number of live and dead cells in each clone at the '...
    'end of the experiment. The clones are sorted based on the total '...
    'cell count.'])
    
    struct('function', @(x,y)LiveDead(x, y, 'Sort', 'live'),...
    'name', 'Live and dead cells at the end (sorted on live count)',...
    'caption', ['The number of live and dead cells in each clone at the '...
    'end of the experiment. The clones are sorted based on the number '...
    'of live cells.'])
    
    struct('function', @LiveCount,...
    'name', 'Live cells',...
    'caption', ['The number of live cells as a function of time. The '...
    'cell count is normalized to percent of the starting population.'])
    
    struct('function', @LiveDeadGhost,...
    'name', 'Live, dead, and ghost cells',...
    'caption', ['The number of live cells, dead cells, and ghost cells '...
    'as a function of time. Ghost cells are cells that would have been '...
    'created through division if the dead cells had never died.'])
    
    struct('function', @ProliferationProfile,...
    'name', 'Proliferation profile',...
    'caption', ['Average cell number over time. Actual cell count '...
    '(jagged) together with modeled curves with (solid) and without '...
    '(dashed) death.'])
    
    struct('function', @SurvivingCount,...
    'name', 'Surviving cells',...
    'caption', ['The number of cells that will be present also in the '...
    'last image, as a function of time. The number is normalized to '...
    'percent of the starting population.'])
    ];

% Plotting styles that can be applied to the different plots.
styles = {@NoStyle, @ScreenStyle, @PrintStyle, @PublicationStyle};
% Names for the plotting styles that the user will see. The 'None'
% alternative means that no changes are made after the plotting function is
% called. 'Screen' is good for detailed analysis on a screen, 'Print' is
% good for printing in a large format, and 'Publication' gives simple and
% legible figures that are suitable for small figures in a publication.
styleNames = {'None' 'Screen' 'Print' 'Publication'};

% Input data for SettingsPanel, used to create ui-objects.
info.Sequences = Setting(...
    'name', 'Image Sequences',...
    'type', 'list',...
    'default', seqDirs,...
    'alternatives_basic', seqDirs,...
    'tooltip', 'Image sequences to include in the analysis.',...
    'callbackfunction', @SequenceCallback);
info.Plots = Setting(...
    'name', 'Plots',...
    'type', 'list',...
    'default', {},...
    'alternatives_basic', {funcs.name},...
    'tooltip', 'Plotting functions to run.',...
    'callbackfunction', @PlotCallback);
info.Version = Setting(...
    'name', 'Version',...
    'type', 'choice',...
    'default', vers{1},...
    'alternatives_basic', vers,...
    'tooltip', 'Tracking results to be analyzed.');
info.Style = Setting(...
    'name', 'Style',...
    'type', 'choice',...
    'default', styleNames{1},...
    'alternatives_basic', styleNames,...
    'tooltip', 'Changes font sizes and other parameters.');

sPanel = SettingsPanel(info,...
    'Parent', mainFigure,...
    'Position', [0 0.25 1 0.75],...
    'Split', 0.25,...
    'MinList', 4,...
    'MaxList', 15);

% Figures with plots generated from the GUI.
figs = [];

% Executes selected plotting functions on selected images sequences.
plotButton = uicontrol(...
    'Parent', mainFigure,...
    'String', 'Plot',...
    'BackgroundColor', get(mainFigure, 'color'),...
    'Style', 'pushbutton',...
    'Units', 'normalized',...
    'Position', [0 0 0.5 0.1],...
    'Enable', 'off',...
    'Tooltip', 'Runs the plotting functions.',...
    'Callback', @PlotButton_Callback);

% Opens a GUI to save all plots that have been created.
saveButton = uicontrol(...
    'Parent', mainFigure,...
    'String', 'Save plots',...
    'BackgroundColor', get(mainFigure, 'color'),...
    'Style', 'pushbutton',...
    'Units', 'normalized',...
    'Position', [0.5 0 0.5 0.1],...
    'Enable', 'off',...  % At the beginning there are not plots to save.
    'Tooltip', 'Opens a GUI where the created plots can be saved.',...
    'Callback', @SaveButton_Callback);

% Text box where descriptions of the selected plotting functions are
% displayed. The text box is an inactive editable text box instead of an
% un-editable text box, because the un-editable text box does not allow
% scrolling.
textBox = uicontrol(...
    'Parent', mainFigure,...
    'Style', 'edit',...         % 'text' does not let the user scroll.
    'Enable', 'inactive',...    % Editable 'off' does not let the user scroll.
    'Max', 2,...                % Allow multiple lines.
    'HorizontalAlignment', 'left',...
    'Units', 'normalized',...
    'Position', [0 0.1 1 0.15]);

% Prevent the user from plotting if there are no tracking results.
if noTracking
    versionMenu = sPanel.GetControl('Version');
    set(versionMenu, 'Enable', 'off')
    set(plotButton, 'Enable', 'off')
end

    function [oCells, oTrimmedStart, oTrimmedEnd] = CreateCells()
        % Loads cells based on the selected version and image sequences.
        %
        % The function loads compact cell representations without blob
        % information, and discards false positive cells. If the image
        % sequences start or end at different points in time, the tracking
        % results are trimmed so that they all start and end at the same
        % time.
        %
        % Outputs:
        % oCells - Array with loaded Cell objects.
        % oTrimmedStart - True if tracking results were trimmed at the
        %                 start.
        % oTrimmedEnd - True if tracking results were trimmed at the end.
        
        ver =  sPanel.GetValue('Version');
        seqSel = aSeqPaths(sPanel.GetIndex('Sequences'));
        oCells = LoadCells(seqSel, ver, 'AreCells', true, 'Compact', true);
        [oCells, oTrimmedStart, oTrimmedEnd] = TrimCells(oCells);
    end

    function SaveButton_Callback(~, ~)
        % Opens a GUI to save the plots that have been generated.
        
        % Take the author string from the first image sequence.
        imData = ImageData(aSeqPaths{1});
        
        figs = intersect(figs, get(0, 'Children'));
        
        % The order of the figures is changed by intersect and therefore
        % the figures must be sorted.
        [~, order] = sort([figs.Number]);
        figs = figs(order);
        
        SavePlotsGUI('Plots', num2cell(figs),...
            'Directory', fullfile(exPaths{1}, 'Analysis'),...
            'Title', 'Plots',...
            'AuthorStr', imData.Get('authorStr'))
    end

    function PlotButton_Callback(~, ~)
        % Generates the selected plots for the selected image sequences.
        
        % Selected plotting functions.
        funcSel = funcs(sPanel.GetIndex('Plots'));
        % Seleted plotting style.
        styleSel = styles{sPanel.GetIndex('style')};
        
        % Trim the tracking results if the image sequences do not start and
        % end at the same points in time.
        [cells, trimmedStart, trimmedEnd] = CreateCells();
        
        % Create a message box if the tracking results were trimmed.
        if trimmedStart || trimmedEnd
            if trimmedStart && ~trimmedEnd
                message = ['All image sequences did not start at the '...
                    'same point in time.'];
            elseif ~trimmedStart && trimmedEnd
                message = ['All image sequences did not end at the '...
                    'same point in time.'];
            else
                message = ['All image sequences did not start nor end '...
                    'at the same point in time.'];
            end
            msgbox(...
                [message 'To handle that, the tracking results had '...
                'to be trimmed.'],...
                'The tracking results were trimmed');
        end
        
        for i = 1:length(funcSel)
            % Create a figure with the appropriate name and caption.
            f = PlotFigure(funcSel(i).name, funcSel(i).caption,...
                'Units', 'normalized',...
                'Position', [0.15 0.05 0.8 0.8]);
            % Create a plot in the figure.
            feval(funcSel(i).function, cells, f)
            % Apply the selected style to the figure.
            FormatFigure(f, styleSel)
            figs = [figs; f]; %#ok<AGROW>
        end
        
        % Allow saving once there are plots to save. The GUI will not
        % notice if all plots are closed.
        set(saveButton, 'Enable', 'on')
    end

    function SequenceCallback(~, ~)
        % Executes when the image sequence selection is changed.
        %
        % The plot button is disabled when no sequences are selected.
        
        if isempty(sPanel.GetIndex('Sequences')) ||...
                isempty(sPanel.GetIndex('Plots'))
            set(plotButton, 'Enable', 'off')
        else
            set(plotButton, 'Enable', 'on')
        end
    end

    function PlotCallback(~, ~)
        % Executes when the plotting function selection is changed.
        %
        % The function prints out descriptions for the selected plotting
        % functions in the designated text box. The plot button is disabled
        % when no functions are selected.
        
        if isempty(sPanel.GetIndex('Sequences')) ||...
                isempty(sPanel.GetIndex('Plots'))
            set(plotButton, 'Enable', 'off')
        else
            set(plotButton, 'Enable', 'on')
        end
        
        % Print out descriptions of the selected plotting functions.
        if ~isempty(sPanel.GetIndex('Plots'))
            funcSel = funcs(sPanel.GetIndex('Plots'));
            % The different paragraphs are saved as cells in a cell array.
            % There will be a line break between each paragraph. One could
            % also use a single string with line breaks, but a single '\n'
            % can give multiple line breaks in the text box (especially
            % when the text box is narrow).
            string = {[funcSel(1).name ':']; funcSel(1).caption};
            for i = 2:length(funcSel)
                string = [string;
                    {''
                    [funcSel(i).name ':']
                    funcSel(i).caption}]; %#ok<AGROW>
            end
            set(textBox, 'String', string)
        end
    end
end