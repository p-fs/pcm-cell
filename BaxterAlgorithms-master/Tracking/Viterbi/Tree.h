#ifndef TREE
#define TREE

#include <cstddef>  // To get NULL.
#include <vector>

class CellNode;
class Detection;
class Event;
class IdleState;
class Mitosis;
class State;

using namespace std;

// Lineage tree of cells. The Tree keeps track of all cells in an image sequence
// and can have more than one connected component. Therefore it represents a graph
// theoretic forest, but we call the class Tree for simplicity. The set of cells
// tracks is empty at first. The cell tracks are represented as trees made up by
// CellNodes that each have exactly one Detection or IdleSate associated with them.
// The nodes link to other nodes to form cell tracks. When a cell divides, the
// parent cells are lniked to the daughter cells. The tree class acts as a factory
// class for CellNodes, which has a private constructor. This prevents the caller
// from likning in Cells without letting the Tree know about them.
class Tree {

public:
	typedef vector<CellNode*>::iterator CellIterator;  // Iterator over mCells.

public:

	// Creates a tree for an image sequence with aNumT images.
    Tree(int aNumT);

	// Destroys all cells in the Tree.
	~Tree();

	// Creates the first CellNode in a new cell track.
	CellNode *CreateCellFirst(IdleState *aState);

	// Extends the cell track ending with aLinkCell with an additional CellNode.
	// The new CellNode will be linked to the previous one by the Event aEvent.
	CellNode *CreateCellLink(CellNode *aLinkCell, Event *aEvent);

	// Returns a pointer to the cell that is currently under construction.
	CellNode* GetActiveCell() { return mActiveCell; }

	// Returns an iterator pointing to the the first cell chain beginning.
	Tree::CellIterator GetBeginFirstCell() { return mFirstCells.begin(); }

	// Function that converts the tree structure into three matrices representing
	// cell tracks and cell divisions.
	//
	// Inputs:
	// aCellA - mNumT x mNumCells matrix concatenated into a vector, that specifies
	// the indices of the detections that the cells are associated with in all images.
	// Images where the cells are not present get the value -1.0.
	// aDivA - mNumCells x 3 matrix concatenated into a vector. The first column specifies
	// the image that the cell divides in and the second and the third column specify the
	// indices of the two daughter cells. For cells that don't divide, the rows are -1.0.
    // aDeathA - Array of length mNumCells, where each element is 1 if the corresponding
    // cell dies and 0 otherwise.
	//
	// Known issues:
	// Does not handle cells that enter and leave the field of view.
	void GetCells(double* aCellA, double* aDivA, double* aDeathA);

	// Returns an iterator pointing to the the position after the last cell chain beginning.
	Tree::CellIterator GetEndFirstCell() { return mFirstCells.end(); }

	void GetIterations(double* aIterationA);

	// Returns the total number of cell chains.
	int GetNumCells() const { return (int)mFirstCells.size(); }

	int GetNumT() const { return mNumT; }

	// Returns true if there is a cell under construction.
	bool HasActiveCell() { return mActiveCell != NULL; }

	// Prints the matrices generated by GetCells, to the command window.
	void Print();

	// Removes one of the cell chain beginnings, and destroys the CellNode.
	void RemoveFirstCell(CellNode* aCell);

	// Specifies a new cell that operations will add detections to.
	void SetActiveCell(CellNode* aCell) { mActiveCell = aCell; }

	void SetIteration(int aIteration) { mIteration = aIteration; }

private:
	// The number of images in the image sequence. Used to produce the right matrices in GetCells.
	int mNumT;
	int mIteration;					// The current tracking iteration. Used to give cells the correct iteration number.
	vector<CellNode*> mFirstCells;  // Starting nodes in all cell tracks.
	CellNode *mActiveCell;			// Cell node that we are currently adding more cell nodes to.
};
#endif