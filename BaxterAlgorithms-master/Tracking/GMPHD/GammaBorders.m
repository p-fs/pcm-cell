function oGamma = GammaBorders(aImData, aQ)
% Generates CellPHDs which represent particles that enter the image.
%
% The function will generate one Gaussian component, representing appearing
% particles, for each side of the image. For a 2D image, there will be 4
% components and for a 3D z-stack there will be 6 components. The Gaussian
% components will have mean values in the middle of the respective image
% borders and the variances in the dimensions perpendicular to the
% borders will be 1E8, so that the distribution will be essentially the
% same along the entire borders. The function works in both 2D and 3D and
% both for Brownian and constant velocity motion.
%
% Inputs:
% aImData - ImageData object of the image sequence.
% aQ - Process noise of the Kalman filter.
%
% Outputs:
% oGamma - CellPHD object which represents a GM-PHD of particles appearing
%          on the image borders.
%
% See also:
% CellPHD

h = aImData.imageHeight;
w = aImData.imageWidth;
d = aImData.numZ;
volume = h*w*d;
particleDensity = aImData.Get('TrackGMn') / volume;

switch aImData.Get('TrackGMModel')
    case 'ConstantPosition'
        if aImData.GetDim() == 2
            % 2D image with Brownian motion.
            
            [m, S, scaling] = AppearanceCovBrownian(aQ(1,1));
            w_gamma_borders = particleDensity *...
                scaling / mvnpdf(0, 0, 1E8);
            
            % Left and right borders in the x-dimension.
            SIGMA_X = diag([S; 1E8]);
            gamma_left = CellPHD(...
                w_gamma_borders,...
                [0.5+m; (h+1)/2],...
                SIGMA_X,...
                nan);
            gamma_right = CellPHD(...
                gamma_borders,...
                [w+0.5-m; (h+1)/2],...
                SIGMA_X,...
                nan);
            
            % Upper and lower borders in the y-dimension.
            SIGMA_Y = diag([1E8; S]);
            gamma_up = CellPHD(...
                w_gamma_borders,...
                [(w+1)/2; 0.5+m],...
                SIGMA_Y,...
                nan);
            gamma_down = CellPHD(...
                w_gamma_borders,...
                [(w+1)/2; w+0.5-m],...
                SIGMA_Y,...
                nan);
            
            oGamma = gamma_left + gamma_right + gamma_up + gamma_down;
        else
            % 3D image with Brownian motion.
            
            [mXY, Sxy, scalingXY] = AppearanceCovBrownian(aQ(1,1));
            w_gamma_borders_xy = particleDensity *...
                scalingXY / mvnpdf(zeros(1,2), zeros(1,2), 1E8*eye(2));
            
            % Left and right borders in the x-dimension.
            SIGMA_X = diag([Sxy; 1E8; 1E8]);
            gamma_left = CellPHD(...
                w_gamma_borders_xy,...
                [0.5+mXY; (h+1)/2; (d+1)/2],...
                SIGMA_X,...
                nan);
            gamma_right = CellPHD(...
                w_gamma_borders_xy,...
                [w+0.5-mXY; (h+1)/2; (d+1)/2],...
                SIGMA_X,...
                nan);
            
            % Upper and lower borders in the y-dimension.
            SIGMA_Y = diag([1E8; Sxy; 1E8]);
            gamma_up = CellPHD(...
                w_gamma_borders_xy,...
                [(w+1)/2; 0.5+mXY; (d+1)/2],...
                SIGMA_Y,...
                nan);
            gamma_down = CellPHD(...
                w_gamma_borders_xy,...
                [(w+1)/2; h+0.5-mXY; (d+1)/2],...
                SIGMA_Y,...
                nan);
            
            [mZ, Sz, scalingZ] = AppearanceCovBrownian(aQ(3,3));
            w_gamma_borders_z = particleDensity *...
                scalingZ / mvnpdf(zeros(1,2), zeros(1,2), 1E8*eye(2));
            
            % Borders above and below in the z-dimension.
            SIGMA_Z = diag([1E8; 1E8; Sz]);
            gamma_front = CellPHD(...
                w_gamma_borders_z,...
                [(w+1)/2; (h+1)/2; 0.5+mZ],...
                SIGMA_Z,...
                nan);
            gamma_behind = CellPHD(...
                w_gamma_borders_z,...
                [(w+1)/2; (h+1)/2; d+0.5-mZ],...
                SIGMA_Z,...
                nan);
            
            oGamma = gamma_left + gamma_right +...
                gamma_up + gamma_down +...
                gamma_front + gamma_behind;
        end
    case {'ConstantVelocity', 'ConstantVelocity_DRO'}
        if aImData.GetDim() == 2
            % 2D image with constant velocity motion.
            
            varV = aImData.Get('TrackGMStdV')^2;
            [m, S, scaling] = AppearanceCovLinear(...
                aImData.Get('TrackGMStdV'),...
                aQ([1 3], [1 3]));
            w_gamma_borders = particleDensity *...
                scaling / mvnpdf(0, 0, 1E8);
            
            % Left and right borders in the x-dimension.
            SIGMA_X = diag([S(1,1); 1E8; S(2,2); varV]);
            SIGMA_X(1,3) = S(1,2);
            SIGMA_X(3,1) = S(2,1);
            gamma_left = CellPHD(...
                w_gamma_borders,...
                [0.5+m(1); (h+1)/2; m(2); 0],...
                SIGMA_X,...
                nan);
            gamma_right = CellPHD(...
                w_gamma_borders,...
                [w+0.5-m(1); (h+1)/2; -m(2); 0],...
                SIGMA_X,...
                nan);
            
            % Upper and lower borders in the y-dimension.
            SIGMA_Y = diag([1E8; S(1,1); varV; S(2,2)]);
            SIGMA_Y(2,4) = S(1,2);
            SIGMA_Y(4,2) = S(2,1);
            gamma_up = CellPHD(...
                w_gamma_borders,...
                [(w+1)/2; 0.5+m(1); 0; m(2)],...
                SIGMA_Y,...
                nan);
            gamma_down = CellPHD(...
                w_gamma_borders,...
                [(w+1)/2; w+0.5-m(1); 0; -m(2)],...
                SIGMA_Y,...
                nan);
            
            oGamma = gamma_left + gamma_right + gamma_up + gamma_down;
        else
            % 3D image with constant velocity motion.
            
            varVxy = aImData.Get('TrackGMStdV')^2;
            varVz = aImData.Get('TrackGMStdV')^2 / aImData.voxelHeight^2;
            [mXY, Sxy, scalingXY] = AppearanceCovLinear(...
                aImData.Get('TrackGMStdV'),...
                aQ([1 3], [1 3]));
            w_gamma_borders_xy = particleDensity *...
                scalingXY / mvnpdf(zeros(1,2), zeros(1,2), 1E8*eye(2));
            
            % Left and right borders in the x-dimension.
            SIGMA_X = diag([Sxy(1,1); 1E8; 1E8; Sxy(2,2); varVxy; varVz]);
            SIGMA_X(1,4) = Sxy(1,2);
            SIGMA_X(4,1) = Sxy(2,1);
            gamma_left = CellPHD(...
                w_gamma_borders_xy,...
                [0.5+mXY(1); (h+1)/2; (d+1)/2; mXY(2); 0; 0],...
                SIGMA_X,...
                nan);
            gamma_right = CellPHD(...
                w_gamma_borders_xy,...
                [w+0.5-mXY(1); (h+1)/2; (d+1)/2; -mXY(2); 0; 0],...
                SIGMA_X,...
                nan);
            
            % Upper and lower borders in the y-dimension.
            SIGMA_Y = diag([1E8; Sxy(1,1); 1E8; varVxy; Sxy(2,2); varVz]);
            SIGMA_Y(2,5) = Sxy(1,2);
            SIGMA_Y(5,2) = Sxy(2,1);
            gamma_up = CellPHD(...
                w_gamma_borders_xy,...
                [(w+1)/2; 0.5+mXY(1); (d+1)/2; 0; mXY(2); 0],...
                SIGMA_Y,...
                nan);
            gamma_down = CellPHD(...
                w_gamma_borders_xy,...
                [(w+1)/2; h+0.5-mXY(1); (d+1)/2; 0; -mXY(2); 0],...
                SIGMA_Y,...
                nan);
            
            [mZ, Sz, scalingZ] = AppearanceCovLinear(...
                aImData.Get('TrackGMStdV')/aImData.voxelHeight,...
                aQ([3 6], [3 6]));
            w_gamma_borders_z = particleDensity *...
                scalingZ / mvnpdf(zeros(1,2), zeros(1,2), 1E8*eye(2));
            
            % Borders above and below in the z-dimension.
            SIGMA_Z = diag([1E8; 1E8; Sz(1,1); varVxy; varVxy; Sz(2,2)]);
            SIGMA_Z(3,6) = Sz(1,2);
            SIGMA_Z(6,3) = Sz(2,1);
            gamma_front = CellPHD(...
                w_gamma_borders_z,...
                [(w+1)/2; (h+1)/2; 0.5+mZ(1); 0; 0; mZ(2)],...
                SIGMA_Z,...
                nan);
            gamma_behind = CellPHD(...
                w_gamma_borders_z,...
                [(w+1)/2; (h+1)/2; d+0.5-mZ(1); 0; 0; -mZ(2)],...
                SIGMA_Z,...
                nan);
            
            oGamma = gamma_left + gamma_right +...
                gamma_up + gamma_down +...
                gamma_front + gamma_behind;
        end
end
end