function BreakClusters(aCells, aBlobs, aT, aImData)
% Breaks cell clusters in one frame using k-means clustering.
%
% BreakClusters breaks the blobs of cell clusters into fragments so that
% each cell gets its own blob. The clusters are broken using k-means
% clustering of the coordinates of the pixels/voxels, with random seeding.
% The resulting fragments are assigned to the cells in the clusters so that
% the sum of the squared distances to the cell positions in the following
% frame is minimized. The function is meant to be used in BipartiteMatch to
% generate accurate cell tracks after track linking with
% ViterbiTrackLinking.
%
% Inputs:
% aCells  - Cells for which the blobs should be updated. It is important
%           that either all or none of the cells in a blob are included, so
%           that the blobs are broken into the correct number of fragments.
% aBlobs  - Array with the Blob objects generated by the segmentation
%           algorithm, for the time point of interest.
% aT      - The time point of interest, for which the blobs will be
%           updated.
% aImData - ImageData object for the image sequence.
%
% See also:
% KMeansSplit, BipartiteMatch, BipartiteMatch_correction,
% ViterbiTrackLinking, Cell, Blob

cells = AliveCells(aCells, aT);

if isempty(cells)
    % If there are no live cells, there is no need to split blobs.
    return
end

% Creating an array for conversion between blob indices and indices in the
% blob array.
blobIndices = nan(max([aBlobs.index]),1);
for i = 1:length(aBlobs)
    blobIndices(aBlobs(i).index) = i;
end

% Count the number of cells in each blob.
counts = zeros(size(aBlobs));
blobCells = cell(size(aBlobs));
for i = 1:length(cells)
    c = cells(i);
    if c.firstFrame <= aT && c.lastFrame >= aT
        index = blobIndices(c.GetBlob(aT).super.index);
        blobCells{index} = [blobCells{index} c];
        counts(index) = counts(index) + 1;
    end
end

% Split the blobs in the right number of fragments using k-means
% clustering.
blobFragments = cell(size(aBlobs));
for index = 1:length(aBlobs)
    if counts(index) > 0
        blobFragments{index} = KMeansSplit(aBlobs(index), counts(index));
    end
end

% The blob fragments can be assigned to the cells randomly, but the
% bipartite matching cannot change what cells undergo mitosis and
% apoptosis, so it is better to assign the fragment which is closest to the
% subsequent position of the cell. This only really matters when a cell in
% a cluster undergoes mitosis in such a way that the daughter cells end up
% in separate blobs in the subsequent image.

for index = 1:length(aBlobs)
    if counts(index) == 0
        continue
    end
    
    % Blob positions in the current frame.
    starts = cat(1, blobFragments{index}.centroid);
    
    cells = blobCells{index};
    % Put the cells that die last.
    deadIndices = [cells.lastFrame] == aT & [cells.died];
    cells = [cells(~deadIndices), cells(deadIndices)];
    
    % Cell positions in the subsequent frame.
    goals = nan(sum(~deadIndices), size(starts,2));
    for i = 1:size(goals,1)
        c = cells(i);
        if aT == aImData.sequenceLength
            % Random assignment in the last frame.
            goals(i,:) = starts(i,:);
        elseif c.lastFrame > aT
            goals(i,:) = c.GetBlob(aT+1).super.centroid;
        elseif c.divided
            % The goal point for a parent is the averages of the child
            % positions.
            goals(i,:) = (c.children(1).GetBlob(aT+1).super.centroid +...
                c.children(2).GetBlob(aT+1).super.centroid)/2;
        elseif c.disappeared
            % Put the goal points for disappearing cells on the closest
            % point on an image border. This may not be correct if the
            % cells disappear randomly. The placement of disappearing cells
            % can however be changed in the bipartite matching.
            
            x = c.GetCx(aT);
            y = c.GetCy(aT);
            
            % Distances to the 4 image borders.
            d1 = x - 1;
            d2 = aImData.imageWidth - x;
            d3 = y - 1;
            d4 = aImData.imageHeight - y;
            
            % Index of the closest border.
            [~, minIndex] = min([d1 d2 d3 d4]);
            
            switch minIndex
                case 1
                    goals(i,1:2) = [1 y];
                case 2
                    goals(i,1:2) = [aImData.imageWidth y];
                case 3
                    goals(i,1:2) = [x 1];
                case 4
                    goals(i,1:2) = [x aImData.imageHeight];
            end
            
            % As in the initial track linking, cells cannot disappear
            % through the top and bottom of a z-stack.
            if aImData.numZ > 1
                goals(i,3) = c.GetCy(aT);
            end
        else
            error('Unexpected ending of a cell track.')
        end
    end
    
    % Assign the blob fragments to the cells.
    matches = MinSquareDist(starts, goals);
    for i = 1:length(blobFragments{index})
        cells(matches(i)).SetBlob(blobFragments{index}(i), aT)
    end
end
end